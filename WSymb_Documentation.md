# WSymb Documentation

## 1. Overview

**WSymb** is a symbolic WCET toolchain built on **OTAWA 2**. It turns an input binary’s control flow into a **Control-Flow Tree (CFT)**, then produces a **parametric WCET formula** (a `.pwf`-style formula file) that can be:

* **simplified** (algebraic rewriting / pruning), and
* **instantiated** (evaluated) for concrete parameter values, using either:

  * a generic runtime evaluator (`libpwcet`), or
  * a generated, specialized C instantiator (via `swymplify` + codegen).

### What’s “new” in this repo (vs the old README)

The repo’s top-level `README.md` describes an older/partial view. The updated capability is:

> **WCET procedure arguments as parameters**: treat the entry procedure’s arguments as *symbolic parameters*, so that loop bounds and branch feasibility conditions can be expressed as linear constraints over those inputs (e.g., Polymalys-style `b:0` for “argument 0”).

This is enabled by feeding WSymb with **two analysis artifacts** (typically produced by Polymalys):

* `constraints.csv` — path/branch constraints
* `loop_bounds.csv` — (possibly parametric) loop bounds

---

## 2. End-to-end pipeline

```
           ┌─────────────────────┐
           │   ARM ELF binary    │
           └─────────┬───────────┘
                     │
                     │  (optional but common)
                     ▼
           ┌─────────────────────┐
           │ Polymalys analysis  │
           │  - constraints.csv  │
           │  - loop_bounds.csv  │
           └─────────┬───────────┘
                     │
                     ▼
           ┌──────────────────────────────┐
           │ WSymb dumpcft (OTAWA)        │
           │  - loads .ff (flow facts)    │
           │  - loads constraints/bounds  │
           │  - builds CFT + emits .pwf   │
           └─────────┬────────────────────┘
                     │
                     ▼
           ┌──────────────────────────────┐
           │ swymplify (OCaml)            │
           │  - simplify .pwf             │
           │  - output: simplified .pwf   │
           │  - or: C / Python codegen    │
           └─────────┬────────────────────┘
                     │
                     ▼
           ┌──────────────────────────────┐
           │ Instantiation / Evaluation   │
           │  - libpwcet runtime          │
           │  - or generated C evaluator  │
           └──────────────────────────────┘
```

---

## 3. Repository layout

```
WSymb/
├─ dumpcft.cpp               # main front-end: binary → CFT → formula
├─ CFTree.cpp, include/CFTree.h
│                            # CFT representation + parsers for CSV artifacts
├─ cftree.eld                # OTAWA plugin descriptor
├─ simplify/                 # OCaml simplifier + C/Python emitters (swymplify)
├─ libpwcet/                 # runtime evaluation library (evaluate())
├─ compiler/                 # Python code generator (from swymplify -p output)
├─ hw/                       # optional hardware models (pipeline, icache)
├─ example/                  # worked example + instantiator skeleton
├─ tests/, benchs/           # test programs / benchmark binaries
└─ do_in.sh                  # helper to switch between OTAWA installs
```

---

## 4. Core concepts and file formats

### 4.1 Flow facts (`.ff`)

WSymb relies on OTAWA flow facts (generated by `mkff`) to avoid “unknown loop bound / unknown branch target” issues. If a loop has no bound in flow facts, OTAWA’s flow-fact loader will complain.

**Typical workflow**

1. Generate skeleton facts:

   ```bash
   <otawa>/bin/mkff program.elf [entry] > program.ff
   ```

2. Fill missing loop bounds / multi-branch targets as needed.

> Practical note: even when `loop_bounds.csv` is available, keep `.ff` consistent and conservative. Use `loop_bounds.csv` to *override / enrich* bounds where available (especially parametric ones).

---

### 4.2 `constraints.csv` (branch/path constraints)

WSymb’s `ConditionParser` expects a **semicolon-separated** CSV (delimiter `;`). The **first line is treated as a header and ignored**.

**Format (per row):**

```
<addr> ; <taken> ; <conditions>
```

* `addr`: integer address of the branching block (as OTAWA sees it)
* `taken`: `"true"` or `"false"`
* `conditions`: a string encoding constraints (typically linear constraints over inputs)

This file is intended to come from Polymalys-style abstract interpretation and aligns with its ability to infer linear relations and parametric constraints.

---

### 4.3 `loop_bounds.csv` (static or parametric loop bounds)

Also **semicolon-separated**, header ignored.

**Format (per row):**

```
<loopId> ; <parametric> ; <bound>
```

* `loopId`: integer loop header ID (OTAWA loop identifier)
* `parametric`: `false` means constant bound; any other value is treated as parametric
* `bound`:

  * if `parametric=false`: integer bound
  * else: expression string (e.g., `b:0 - 1`)

Polymalys’ documentation describes the common convention where `b:0` denotes “parameter 0” (e.g., function argument 0) in exported parametric bounds.

---

### 4.4 `.pfl` (parametric WCET for callees; optional)

When the WCET model treats some callees as parametric “black boxes,” WSymb can read a `.pfl` alongside the binary to map function names to parameter IDs used inside formulas, so instantiation can supply those costs later.

---

### 4.5 The formula file (`.pwf`)

`dumpcft` emits a symbolic WCET formula plus loop hierarchy metadata. `swymplify` reads it and can:

* print simplified formulas,
* compile the formula into C structures / code, or
* emit a Python representation for downstream C code generation (`compiler/compiler.py`).

The syntax supports sequencing, alternatives, and loop constructs (see examples under `simplify/test/*.pwf`).

---

## 5. Build & installation

### 5.1 Prerequisites (typical)

* A working **OTAWA 2** setup (with loaders for the target architecture, commonly ARM in this workflow)
* Build tools: `make`, `g++`, `cmake` (as required by the OTAWA toolchain)
* **OCaml toolchain** for `simplify/` (`ocamlc`, `ocamllex`, `ocamlyacc`)
* Optional: cross-compilers for building instantiators for embedded targets

### 5.2 Two-OTAWA setup (`do_in.sh`)

This repo assumes two OTAWA installs may be maintained (e.g., one for Polymalys and one for WSymb) and switches environment variables (`OTAWA_HOME`, `PATH`, `LD_LIBRARY_PATH`) via:

```bash
./do_in.sh wsymb <command...>
./do_in.sh polymalys <command...>
```

(Adjust paths inside `do_in.sh` to local OTAWA build/install locations.)

### 5.3 Build steps (high level)

* Build/install the WSymb plugin + tools (top-level `Makefile`)
* Build `simplify/` (produces `swymplify`)
* Build `libpwcet/` (produces a static library to link against)

---

## 6. Usage guide (updated “procedure arguments as parameters” workflow)

The goal is to compute the WCET of an entry function `entry` in `program.elf`, with WCET depending on its arguments.

### Step 0 — Prepare the binary

Produce an **ARM ELF** (or any architecture supported by the OTAWA loader in use). Example:

```bash
arm-none-eabi-gcc -O2 -g -o program.elf program.c
```

### Step 1 — Generate flow facts

```bash
./do_in.sh wsymb <otawa-wsymb>/bin/mkff program.elf entry > program.ff
# Edit program.ff to resolve any remaining '?' (bounds/targets) as required.
```

### Step 2 — Run Polymalys to infer parametric facts (recommended)

Run Polymalys on the binary/function to obtain:

* `constraints.csv`
* `loop_bounds.csv`

(Exact commands depend on the Polymalys wrapper scripts in use; place both CSV files in the working directory used for Step 3.)

### Step 3 — Generate the WCET formula with `dumpcft`

```bash
./do_in.sh wsymb <wsymb>/dumpcft program.elf program.pwf entry
```

Common outputs in the working directory include:

* `program.pwf`: the formula + hierarchy
* a C-like “decompiled” trace file (useful for debugging/control-flow inspection), depending on the build/configuration

### Step 4 — Simplify the formula (`swymplify`)

From `simplify/`, run:

```bash
./swymplify program.pwf > program.simplified.pwf
```

#### Option A: generate C directly

```bash
./swymplify -c -o program_inst.c program.pwf
```

#### Option B: generate Python (for optimized codegen)

```bash
./swymplify -c -p -o program_inst.py program.pwf
# then
python3 program_inst.py > program_inst.c
```

> Note: in this repo, `-p` produces a Python representation (despite some older text describing it differently).

### Step 5 — Build and run an instantiator

#### Generic evaluation with `libpwcet`

Use the `example/pwcet_instantiator.c` pattern:

* implement `param_valuation()` to supply parameter values (bounds / costs)
* call `evaluate(&f, &loopinfo, param_valuation, bparam_valuation, data)`

This provides a direct path to supply:

* entry-argument values (the “as-parameters” inputs), and
* parametric callee WCETs (when `.pfl` is used).

#### Generated C instantiator

Compile `program_inst.c` and link with `libpwcet.a` from `libpwcet/`.

---

## 7. Hardware modeling (optional)

`dumpcft` supports compile-time toggles for:

* `PIPELINE` → loads `hw/processor.xml`
* `ICACHE` → loads `hw/cache.xml`

These toggles can be enabled to make the formula reflect a specific micro-architectural timing model (as supported by the OTAWA configuration).

---

## 8. Troubleshooting checklist

### “no bound for loop …” / FlowFactLoader errors

* Cause: `.ff` still contains unresolved loop bounds, or OTAWA cannot associate provided bounds with detected loops.
* Fix: regenerate `.ff` with `mkff`, then ensure `loop "func"+offset bound;` entries are fully specified for loops not covered by `loop_bounds.csv`.

### `constraints.csv` / `loop_bounds.csv` not taking effect

* Confirm both files are in the **current working directory** when invoking `dumpcft`
* Confirm both files are **semicolon-separated** and contain a header line
* Confirm loop IDs / addresses match what OTAWA reports for the binary under analysis

### Instantiation produces nonsensical / negative values

* Cause: parameter mapping is inconsistent.
* Fix: ensure the expression language in `loop_bounds.csv` matches the parameter naming convention used during instantiation (e.g., `b:0` for argument 0 as exported by Polymalys).

---

## 9. License

The repo ships `COPYING` as **LGPL v2.1** (or later).

